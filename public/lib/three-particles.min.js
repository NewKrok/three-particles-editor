import*as t from"THREE";var e={300:t=>{const e=t=>t,r={In:t=>t*t,Out:t=>t*(2-t),InOut(t){let e=2*t;return e<1?.5*e*e:(e-=1,-.5*(e*(e-2)-1))}},i={In:t=>t*t*t,Out:t=>--t*t*t+1,InOut(t){let e=2*t;return e<1?.5*e*e*e:(e-=2,.5*(e*e*e+2))}},a={In:t=>t*t*t*t,Out:t=>1- --t*t*t*t,InOut(t){let e=2*t;return e<1?.5*e*e*e*e:(e-=2,-.5*(e*e*e*e-2))}},n={In:t=>t*t*t*t*t,Out:t=>--t*t*t*t*t+1,InOut(t){let e=2*t;return e<1?.5*e*e*e*e*e:(e-=2,.5*(e*e*e*e*e+2))}},o={In:t=>1-Math.cos(t*Math.PI/2),Out:t=>Math.sin(t*Math.PI/2),InOut:t=>.5*(1-Math.cos(Math.PI*t))},s={In:t=>0===t?0:1024**(t-1),Out:t=>1===t?1:1-2**(-10*t),InOut(t){if(0===t)return 0;if(1===t)return 1;const e=2*t;return e<1?.5*1024**(e-1):.5*(2-2**(-10*(e-1)))}},l={In:t=>1-Math.sqrt(1-t*t),Out:t=>Math.sqrt(1- --t*t),InOut(t){let e=2*t;return e<1?-.5*(Math.sqrt(1-e*e)-1):(e-=2,.5*(Math.sqrt(1-e*e)+1))}},c={In(t){let e=.1;let r;return 0===t?0:1===t?1:(e<1?(e=1,r=.1):r=.4*Math.asin(1/e)/(2*Math.PI),-e*2**(10*(t-=1))*Math.sin((t-r)*(2*Math.PI)/.4))},Out(t){let e=.1;let r;return 0===t?0:1===t?1:(e<1?(e=1,r=.1):r=.4*Math.asin(1/e)/(2*Math.PI),e*2**(-10*t)*Math.sin((t-r)*(2*Math.PI)/.4)+1)},InOut(t){let e=.1;const r=.4;let i;if(0===t)return 0;if(1===t)return 1;e<1?(e=1,i=.1):i=r*Math.asin(1/e)/(2*Math.PI);const a=2*t;if(a<1){const t=a-1;return e*2**(10*t)*Math.sin((t-i)*(2*Math.PI)/r)*-.5}const n=a-1;return e*2**(-10*n)*Math.sin((n-i)*(2*Math.PI)/r)*.5+1}},d={In(t){const e=1.70158;return t*t*((e+1)*t-e)},Out(t){const e=1.70158;return--t*t*((e+1)*t+e)+1},InOut(t){const e=2.5949095;let r=2*t;return r<1?r*r*((e+1)*r-e)*.5:(r-=2,.5*(r*r*((e+1)*r+e)+2))}},u={In:t=>1-u.Out(1-t),Out(t){if(t<1/2.75)return 7.5625*t*t;if(t<2/2.75){const e=t-1.5/2.75;return 7.5625*e*e+.75}if(t<2.5/2.75){const e=t-2.25/2.75;return 7.5625*e*e+.9375}const e=t-2.625/2.75;return 7.5625*e*e+.984375},InOut:t=>t<.5?.5*u.In(2*t):.5*u.Out(2*t-1)+.5},m={Quadratic:r,Cubic:i,Quartic:a,Quintic:n,Sinusoidal:o,Exponential:s,Circular:l,Elastic:c,Back:d,Bounce:u},y=(t,e,r)=>Object.defineProperty(t,e,{value:r});for(const t of Object.keys(m)){const e=m[t],r=t.toLowerCase();y(m,r,e);for(const i of Object.keys(e)){const a=e[i],n=i.toLowerCase();y(m,`${t}.${i}`,a),y(m,`${r}.${n}`,a),y(e,n,a)}}m.Linear=e,y(m,"linear",e),t.exports=m,"undefined"!=typeof window&&(window.Easing=m)}},r={};function i(t){var a=r[t];if(void 0!==a)return a.exports;var n=r[t]={exports:{}};return e[t](n,n.exports,i),n.exports}i.d=(t,e)=>{for(var r in e)i.o(e,r)&&!i.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var a={};i.d(a,{pB:()=>P,U_:()=>F,rU:()=>v,M4:()=>h,$H:()=>f,hp:()=>g,l$:()=>p,Y$:()=>O,Tt:()=>s,JP:()=>x,eL:()=>W,Hc:()=>c,Ao:()=>m,iy:()=>I,Px:()=>Q,rJ:()=>b,Pj:()=>l,YR:()=>j});const n=[],o=(t,e)=>{let r=1;for(let i=1;i<=e;i++)r*=(t+1-i)/i;return r},s=(t,e)=>{const r=n.find((t=>t.bezierPoints===e));if(r)return r.referencedBy.includes(t)||r.referencedBy.push(t),r.curveFunction;const i={referencedBy:[t],bezierPoints:e,curveFunction:t=>{if(t<0)return e[0].y;if(t>1)return e[e.length-1].y;let r=0,i=e.length-1;e.find(((e,a)=>{const n=t<(e.percentage??0);return n?i=a:void 0!==e.percentage&&(r=a),n}));const a=i-r,n=(t-(e[r].percentage??0))/((e[i].percentage??1)-(e[r].percentage??0));let s=0;for(let t=0;t<=a;t++){const i=e[r+t];s+=o(a,t)*Math.pow(1-n,a-t)*Math.pow(n,t)*i.y}return s}};return n.push(i),i.curveFunction},l=t=>{for(;;){const e=n.findIndex((e=>e.referencedBy.includes(t)));if(-1===e)break;const r=n[e];r.referencedBy=r.referencedBy.filter((e=>e!==t)),0===r.referencedBy.length&&n.splice(e,1)}},c=()=>n.length;var d=i(300);const u={LINEAR:d.Linear.None,QUADRATIC_IN:d.Quadratic.In,QUADRATIC_OUT:d.Quadratic.Out,QUADRATIC_IN_OUT:d.Quadratic.InOut,CUBIC_IN:d.Cubic.In,CUBIC_OUT:d.Cubic.Out,CUBIC_IN_OUT:d.Cubic.InOut,QUARTIC_IN:d.Quartic.In,QUARTIC_OUT:d.Quartic.Out,QUARTIC_IN_OUT:d.Quartic.InOut,QUINTIC_IN:d.Quintic.In,QUINTIC_OUT:d.Quintic.Out,QUINTIC_IN_OUT:d.Quintic.InOut,SINUSOIDAL_IN:d.Sinusoidal.In,SINUSOIDAL_OUT:d.Sinusoidal.Out,SINUSOIDAL_IN_OUT:d.Sinusoidal.InOut,EXPONENTIAL_IN:d.Exponential.In,EXPONENTIAL_OUT:d.Exponential.Out,EXPONENTIAL_IN_OUT:d.Exponential.InOut,CIRCULAR_IN:d.Circular.In,CIRCULAR_OUT:d.Circular.Out,CIRCULAR_IN_OUT:d.Circular.InOut,ELASTIC_IN:d.Elastic.In,ELASTIC_OUT:d.Elastic.Out,ELASTIC_IN_OUT:d.Elastic.InOut,BACK_IN:d.Back.In,BACK_OUT:d.Back.Out,BACK_IN_OUT:d.Back.InOut,BOUNCE_IN:d.Bounce.In,BOUNCE_OUT:d.Bounce.Out,BOUNCE_IN_OUT:d.Bounce.InOut},m=t=>"function"==typeof t?t:u[t];const y=(t=>{var e={};return i.d(e,t),e})({AdditiveBlending:()=>t.AdditiveBlending,BufferAttribute:()=>t.BufferAttribute,BufferGeometry:()=>t.BufferGeometry,CanvasTexture:()=>t.CanvasTexture,Euler:()=>t.Euler,MathUtils:()=>t.MathUtils,MultiplyBlending:()=>t.MultiplyBlending,NoBlending:()=>t.NoBlending,NormalBlending:()=>t.NormalBlending,Object3D:()=>t.Object3D,Points:()=>t.Points,Quaternion:()=>t.Quaternion,ShaderMaterial:()=>t.ShaderMaterial,SubtractiveBlending:()=>t.SubtractiveBlending,Vector2:()=>t.Vector2,Vector3:()=>t.Vector3}),p=(t,e,r,i,{radius:a,radiusThickness:n,arc:o})=>{const s=Math.random()*(o/360),l=Math.random(),c=Math.random(),d=2*Math.PI*s,u=Math.acos(2*l-1),m=Math.sin(u),y=m*Math.cos(d),p=m*Math.sin(d),f=Math.cos(u),v=1-n;t.x=a*v*y+a*n*c*y,t.y=a*v*p+a*n*c*p,t.z=a*v*f+a*n*c*f,t.applyQuaternion(e);const h=1/t.length();r.set(t.x*h*i,t.y*h*i,t.z*h*i),r.applyQuaternion(e)},f=(t,e,r,i,{radius:a,radiusThickness:n,arc:o,angle:s=90})=>{const l=2*Math.PI*Math.random()*(o/360),c=Math.random(),d=Math.cos(l),u=Math.sin(l),m=1-n;t.x=a*m*d+a*n*c*d,t.y=a*m*u+a*n*c*u,t.z=0,t.applyQuaternion(e);const p=t.length(),f=Math.abs(p/a*y.MathUtils.degToRad(s)),v=Math.sin(f),h=1/p;r.set(t.x*v*h*i,t.y*v*h*i,Math.cos(f)*i),r.applyQuaternion(e)},v=(t,e,r,i,{scale:a,emitFrom:n})=>{const o=a;switch(n){case"VOLUME":t.x=Math.random()*o.x-o.x/2,t.y=Math.random()*o.y-o.y/2,t.z=Math.random()*o.z-o.z/2;break;case"SHELL":const e=Math.floor(6*Math.random()),r=e%3,i=[];i[r]=e>2?1:0,i[(r+1)%3]=Math.random(),i[(r+2)%3]=Math.random(),t.x=i[0]*o.x-o.x/2,t.y=i[1]*o.y-o.y/2,t.z=i[2]*o.z-o.z/2;break;case"EDGE":const a=Math.floor(6*Math.random()),n=a%3,s=Math.floor(4*Math.random()),l=[];l[n]=a>2?1:0,l[(n+1)%3]=s<2?Math.random():s-2,l[(n+2)%3]=s<2?s:Math.random(),t.x=l[0]*o.x-o.x/2,t.y=l[1]*o.y-o.y/2,t.z=l[2]*o.z-o.z/2}t.applyQuaternion(e),r.set(0,0,i),r.applyQuaternion(e)},h=(t,e,r,i,{radius:a,radiusThickness:n,arc:o})=>{const s=2*Math.PI*Math.random()*(o/360),l=Math.random(),c=Math.cos(s),d=Math.sin(s),u=1-n;t.x=a*u*c+a*n*l*c,t.y=a*u*d+a*n*l*d,t.z=0,t.applyQuaternion(e);const m=1/t.length();r.set(t.x*m*i,t.y*m*i,0),r.applyQuaternion(e)},g=(t,e,r,i,{rotation:a,scale:n})=>{const o=n,s=a,l=Math.random()*o.x-o.x/2,c=Math.random()*o.y-o.y/2,d=y.MathUtils.degToRad(s.x),u=y.MathUtils.degToRad(s.y);t.x=l*Math.cos(u),t.y=c*Math.cos(d),t.z=l*Math.sin(u)-c*Math.sin(d),t.applyQuaternion(e),r.set(0,0,i),r.applyQuaternion(e)},x=()=>{try{const t=document.createElement("canvas"),e=64;t.width=e,t.height=e;const r=t.getContext("2d");if(r){const i=e/2,a=e/2,n=e/2-2;r.beginPath(),r.arc(i,a,n,0,2*Math.PI,!1),r.fillStyle="white",r.fill();const o=new y.CanvasTexture(t);return o.needsUpdate=!0,o}return null}catch(t){return null}},b=t=>"number"!=typeof t&&"type"in t,I=(t,e)=>{if("BEZIER"===e.type)return s(t,e.bezierPoints);if("EASING"===e.type)return e.curveFunction;throw new Error(`Unsupported value type: ${e}`)},O=(t,e,r=0)=>{if("number"==typeof e)return e;if("min"in e&&"max"in e)return e.min===e.max?e.min??0:y.MathUtils.randFloat(e.min??0,e.max??1);const i=e;return I(t,i)(r)*(i.scale??1)},M=new y.Vector3(0,0,0),z=new y.Euler,P=({delta:t,generalData:e,normalizedConfig:r,attributes:i,particleLifetimePercentage:a,particleIndex:n})=>{const{particleSystemId:o,startValues:s,lifetimeValues:l,linearVelocityData:c,orbitalVelocityData:d,noise:u}=e,m=3*n,y=i.position.array;if(c){const{speed:e,valueModifiers:r}=c[n],o=r.x?r.x(a):e.x,s=r.y?r.y(a):e.y,l=r.z?r.z(a):e.z;y[m]+=o*t,y[m+1]+=s*t,y[m+2]+=l*t,i.position.needsUpdate=!0}if(d){const{speed:e,positionOffset:r,valueModifiers:o}=d[n];y[m]-=r.x,y[m+1]-=r.y,y[m+2]-=r.z;const s=o.x?o.x(a):e.x,l=o.y?o.y(a):e.y,c=o.z?o.z(a):e.z;z.set(s*t,c*t,l*t),r.applyEuler(z),y[m]+=r.x,y[m+1]+=r.y,y[m+2]+=r.z,i.position.needsUpdate=!0}if(r.sizeOverLifetime.isActive){const t=O(o,r.sizeOverLifetime.lifetimeCurve,a);i.size.array[n]=s.startSize[n]*t,i.size.needsUpdate=!0}if(r.opacityOverLifetime.isActive){const t=O(o,r.opacityOverLifetime.lifetimeCurve,a);i.colorA.array[n]=s.startOpacity[n]*t,i.colorA.needsUpdate=!0}if(l.rotationOverLifetime&&(i.rotation.array[n]+=l.rotationOverLifetime[n]*t*.02,i.rotation.needsUpdate=!0),u.isActive){const{sampler:t,strength:e,offsets:r,positionAmount:o,rotationAmount:s,sizeAmount:l}=u;let c;const d=10*(a+(r?r[n]:0))*e,p=.15*e;M.set(d,0,0),c=t.get3(M),y[m]+=c*p*o,0!==s&&(i.rotation.array[n]+=c*p*s,i.rotation.needsUpdate=!0),0!==l&&(i.size.array[n]+=c*p*l,i.size.needsUpdate=!0),M.set(d,d,0),c=t.get3(M),y[m+1]+=c*p*o,M.set(d,d,d),c=t.get3(M),y[m+2]+=c*p*o,i.position.needsUpdate=!0}};const w=(t,e,r={skippedProperties:[],applyToFirstObject:!1})=>{const i={};return Object.keys(t).forEach((a=>{r.skippedProperties&&r.skippedProperties.includes(a)||("object"==typeof t[a]&&t[a]&&e[a]&&!Array.isArray(t[a])?i[a]=w(t[a],e[a],r):(i[a]=0===e[a]?0:!1!==e[a]&&(e[a]||t[a]),r.applyToFirstObject&&(t[a]=i[a])))})),i},A=new y.Vector3,S=new y.Quaternion,_=new y.Vector3,C=new y.Vector3,L=new y.Quaternion,V=new y.Vector3;class T extends y.Object3D{constructor(){super()}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null!==this.parent?(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorld.decompose(C,L,V),this.matrix.decompose(A,S,_),this.matrixWorld.compose(C,S,V)):this.matrixWorld.copy(this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);for(let e=0,r=this.children.length;e<r;e++)this.children[e].updateMatrixWorld(t)}}var E=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];class U{constructor(t){const e=[new y.Vector3(1,1,0),new y.Vector3(-1,1,0),new y.Vector3(1,-1,0),new y.Vector3(-1,-1,0),new y.Vector3(1,0,1),new y.Vector3(-1,0,1),new y.Vector3(1,0,-1),new y.Vector3(-1,0,-1),new y.Vector3(0,1,1),new y.Vector3(0,-1,1),new y.Vector3(0,1,-1),new y.Vector3(0,-1,-1)];var r=new Array(512),i=new Array(512);t||(t=1),t*=65536,(t=Math.floor(t))<256&&(t|=t<<8);for(var a=0;a<256;a++){var n;n=1&a?E[a]^255&t:E[a]^t>>8&255,r[a]=r[a+256]=n,i[a]=i[a+256]=e[n%12]}this._seed=t,this._offsetMatrix=[new y.Vector3(0,0,0),new y.Vector3(0,0,1),new y.Vector3(0,1,0),new y.Vector3(0,1,1),new y.Vector3(1,0,0),new y.Vector3(1,0,1),new y.Vector3(1,1,0),new y.Vector3(1,1,1)],this.shaderChunk={defines:"",header:'#define GLSLIFY 1\n// From https://github.com/hughsk/glsl-noise/blob/master/periodic/2d.glsl\n\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec2 fade(vec2 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n// Classic Perlin noise, periodic variant\nfloat perlin(vec2 P) {\n\n  vec2 rep = vec2(255.0, 255.0);\n\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x, gy.x);\n  vec2 g10 = vec2(gx.y, gy.y);\n  vec2 g01 = vec2(gx.z, gy.z);\n  vec2 g11 = vec2(gx.w, gy.w);\n\n  vec4 norm = taylorInvSqrt(\n      vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return map(2.3 * n_xy, -1.0, 1.0, 0.0, 1.0);\n}\n\nfloat fbm(vec2 pos, vec4 props) {\n  float persistance = props.x;\n  float lacunarity = props.y;\n  float redistribution = props.z;\n  int octaves = int(props.w);\n\n  float result = 0.0;\n  float amplitude = 1.0;\n  float frequency = 1.0;\n  float maximum = amplitude;\n\n  for (int i = 0; i < 2; i++) {\n\n    vec2 p = pos.xy * frequency;\n\n    float noiseVal = perlin(p);\n    result += noiseVal * amplitude;\n\n    frequency *= lacunarity;\n    amplitude *= persistance;\n    maximum += amplitude;\n  }\n\n  float redistributed = pow(result, redistribution);\n  return redistributed / maximum;\n}\n',main:"",uniforms:[{three_noise_seed:this._seed}]},this.perm=r,this.gradP=i}_fade(t){return t*t*t*(t*(6*t-15)+10)}_lerp(t,e,r){return(1-r)*t+r*e}_gradient(t){return t instanceof y.Vector3?t.x+this.perm[t.y+this.perm[t.z]]:t.x+this.perm[t.y]}static map(t,e,r,i,a){return(t-e)*(a-i)/(r-e)+i}get2(t){void 0!==t.z&&(t=new y.Vector2(t.x,t.y));const e=new y.Vector2(Math.floor(t.x),Math.floor(t.y));t.sub(e),e.x&=255,e.y&=255;const r=[];for(let i=0;i<4;i++){const a=this._offsetMatrix[2*i],n=new y.Vector2(a.x,a.y),o=this.gradP[this._gradient((new y.Vector2).addVectors(e,n))],s=new y.Vector2(o.x,o.y),l=(new y.Vector2).subVectors(t,n);r.push(s.dot(l))}const i=this._fade(t.x),a=this._fade(t.y);return this._lerp(this._lerp(r[0],r[2],i),this._lerp(r[1],r[3],i),a)}get3(t){if(void 0===t.z)throw"Input to Perlin::get3() must be of type THREE.Vector3";const e=new y.Vector3(Math.floor(t.x),Math.floor(t.y),Math.floor(t.z));t.sub(e),e.x&=255,e.y&=255,e.z&=255;const r=[];for(let i=0;i<8;i++){const a=this._offsetMatrix[i],n=this.gradP[this._gradient((new y.Vector3).addVectors(e,a))],o=(new y.Vector3).subVectors(t,a);r.push(n.dot(o))}const i=this._fade(t.x),a=this._fade(t.y),n=this._fade(t.z);return this._lerp(this._lerp(this._lerp(r[0],r[4],i),this._lerp(r[1],r[5],i),n),this._lerp(this._lerp(r[2],r[6],i),this._lerp(r[3],r[7],i),n),a)}}class B{constructor(t){const{seed:e,scale:r,persistance:i,lacunarity:a,octaves:n,redistribution:o}=t;this._noise=new U(e),this._scale=r||1,this._persistance=i||.5,this._lacunarity=a||2,this._octaves=n||6,this._redistribution=o||1}get2(t){let e=0,r=1,i=1,a=r,n=this._noise.get2.bind(this._noise);for(let o=0;o<this._octaves;o++){e+=n(new y.Vector2(t.x*this._scale*i,t.y*this._scale*i))*r,i*=this._lacunarity,r*=this._persistance,a+=r}return Math.pow(e,this._redistribution)/a}get3(t){let e=0,r=1,i=1,a=r,n=this._noise.get3.bind(this._noise);for(let o=0;o<this._octaves;o++){e+=n(new y.Vector3(t.x*this._scale*i,t.y*this._scale*i,t.z*this._scale*i))*r,i*=this._lacunarity,r*=this._persistance,a+=r}return Math.pow(e,this._redistribution)/a}}let R=0,N=[];const F={"THREE.NoBlending":y.NoBlending,"THREE.NormalBlending":y.NormalBlending,"THREE.AdditiveBlending":y.AdditiveBlending,"THREE.SubtractiveBlending":y.SubtractiveBlending,"THREE.MultiplyBlending":y.MultiplyBlending},Q=()=>JSON.parse(JSON.stringify(D)),D={transform:{position:new y.Vector3,rotation:new y.Vector3,scale:new y.Vector3(1,1,1)},duration:5,looping:!0,startDelay:0,startLifetime:5,startSpeed:1,startSize:1,startOpacity:1,startRotation:0,startColor:{min:{r:1,g:1,b:1},max:{r:1,g:1,b:1}},gravity:0,simulationSpace:"LOCAL",maxParticles:100,emission:{rateOverTime:10,rateOverDistance:0},shape:{shape:"SPHERE",sphere:{radius:1,radiusThickness:1,arc:360},cone:{angle:25,radius:1,radiusThickness:1,arc:360},circle:{radius:1,radiusThickness:1,arc:360},rectangle:{rotation:{x:0,y:0},scale:{x:1,y:1}},box:{scale:{x:1,y:1,z:1},emitFrom:"VOLUME"}},map:void 0,renderer:{blending:y.NormalBlending,discardBackgroundColor:!1,backgroundColorTolerance:1,backgroundColor:{r:1,g:1,b:1},transparent:!0,depthTest:!0,depthWrite:!1},velocityOverLifetime:{isActive:!1,linear:{x:0,y:0,z:0},orbital:{x:0,y:0,z:0}},sizeOverLifetime:{isActive:!1,lifetimeCurve:{type:"BEZIER",scale:1,bezierPoints:[{x:0,y:0,percentage:0},{x:1,y:1,percentage:1}]}},opacityOverLifetime:{isActive:!1,lifetimeCurve:{type:"BEZIER",scale:1,bezierPoints:[{x:0,y:0,percentage:0},{x:1,y:1,percentage:1}]}},rotationOverLifetime:{isActive:!1,min:0,max:0},noise:{isActive:!1,useRandomOffset:!1,strength:1,frequency:.5,octaves:1,positionAmount:1,rotationAmount:0,sizeAmount:0},textureSheetAnimation:{tiles:new y.Vector2(1,1),timeMode:"LIFETIME",fps:30,startFrame:0}},k=(t,{shape:e,sphere:r,cone:i,circle:a,rectangle:n,box:o},s,l,c)=>{const d=O(t.particleSystemId,s,t.normalizedLifetimePercentage);switch(e){case"SPHERE":p(l,t.wrapperQuaternion,c,d,r);break;case"CONE":f(l,t.wrapperQuaternion,c,d,i);break;case"CIRCLE":h(l,t.wrapperQuaternion,c,d,a);break;case"RECTANGLE":g(l,t.wrapperQuaternion,c,d,n);break;case"BOX":v(l,t.wrapperQuaternion,c,d,o)}},W=(t=D,e)=>{const r=e||Date.now(),i={particleSystemId:R++,normalizedLifetimePercentage:0,distanceFromLastEmitByDistance:0,lastWorldPosition:new y.Vector3(-99999),currentWorldPosition:new y.Vector3(-99999),worldPositionChange:new y.Vector3,worldQuaternion:new y.Quaternion,wrapperQuaternion:new y.Quaternion,lastWorldQuaternion:new y.Quaternion(-99999),worldEuler:new y.Euler,gravityVelocity:new y.Vector3(0,0,0),startValues:{},linearVelocityData:void 0,orbitalVelocityData:void 0,lifetimeValues:{},creationTimes:[],noise:{isActive:!1,strength:0,positionAmount:0,rotationAmount:0,sizeAmount:0},isEnabled:!0},a=w(D,t);let n=a.map||x();const{transform:o,duration:s,looping:c,startDelay:d,startLifetime:u,startSpeed:m,startSize:p,startRotation:f,startColor:v,startOpacity:h,gravity:g,simulationSpace:M,maxParticles:z,emission:A,shape:S,renderer:_,noise:C,velocityOverLifetime:L,onUpdate:V,onComplete:E,textureSheetAnimation:U}=a;"string"==typeof _?.blending&&(_.blending=F[_.blending]);const Q=Array.from({length:z},(()=>new y.Vector3)),W=Array.from({length:z},(()=>new y.Vector3));i.creationTimes=Array.from({length:z},(()=>0)),L.isActive&&(i.linearVelocityData=Array.from({length:z},(()=>({speed:new y.Vector3(L.linear.x?O(i.particleSystemId,L.linear.x,0):0,L.linear.y?O(i.particleSystemId,L.linear.y,0):0,L.linear.z?O(i.particleSystemId,L.linear.z,0):0),valueModifiers:{x:b(L.linear.x||0)?I(i.particleSystemId,L.linear.x):void 0,y:b(L.linear.y||0)?I(i.particleSystemId,L.linear.y):void 0,z:b(L.linear.z||0)?I(i.particleSystemId,L.linear.z):void 0}}))),i.orbitalVelocityData=Array.from({length:z},(()=>({speed:new y.Vector3(L.orbital.x?O(i.particleSystemId,L.orbital.x,0):0,L.orbital.y?O(i.particleSystemId,L.orbital.y,0):0,L.orbital.z?O(i.particleSystemId,L.orbital.z,0):0),valueModifiers:{x:b(L.orbital.x||0)?I(i.particleSystemId,L.orbital.x):void 0,y:b(L.orbital.y||0)?I(i.particleSystemId,L.orbital.y):void 0,z:b(L.orbital.z||0)?I(i.particleSystemId,L.orbital.z):void 0},positionOffset:new y.Vector3}))));["startSize","startOpacity"].forEach((t=>{i.startValues[t]=Array.from({length:z},(()=>O(i.particleSystemId,a[t],0)))}));["rotationOverLifetime"].forEach((t=>{const e=a[t];e.isActive&&(i.lifetimeValues[t]=Array.from({length:z},(()=>y.MathUtils.randFloat(e.min,e.max))))})),i.noise={isActive:C.isActive,strength:C.strength,positionAmount:C.positionAmount,rotationAmount:C.rotationAmount,sizeAmount:C.sizeAmount,sampler:C.isActive?new B({seed:Math.random(),scale:C.frequency,octaves:C.octaves}):void 0,offsets:C.useRandomOffset?Array.from({length:z},(()=>100*Math.random())):void 0};const j=new y.ShaderMaterial({uniforms:{elapsed:{value:0},map:{value:n},tiles:{value:U.tiles},fps:{value:U.fps},useFPSForFrameIndex:{value:"FPS"===U.timeMode},backgroundColor:{value:_.backgroundColor},discardBackgroundColor:{value:_.discardBackgroundColor},backgroundColorTolerance:{value:_.backgroundColorTolerance}},vertexShader:"\n  attribute float size;\n  attribute float colorR;\n  attribute float colorG;\n  attribute float colorB;\n  attribute float colorA;\n  attribute float lifetime;\n  attribute float startLifetime;\n  attribute float rotation;\n  attribute float startFrame;\n\n  varying mat4 vPosition;\n  varying vec4 vColor;\n  varying float vLifetime;\n  varying float vStartLifetime;\n  varying float vRotation;\n  varying float vStartFrame;\n\n  void main()\n  {\n    vColor = vec4(colorR, colorG, colorB, colorA);\n    vLifetime = lifetime;\n    vStartLifetime = startLifetime;\n    vRotation = rotation;\n    vStartFrame = startFrame;\n\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    gl_PointSize = size * (100.0 / length(mvPosition.xyz));\n    gl_Position = projectionMatrix * mvPosition;\n  }\n",fragmentShader:"\n  uniform sampler2D map;\n  uniform float elapsed;\n  uniform float fps;\n  uniform bool useFPSForFrameIndex;\n  uniform vec2 tiles;\n  uniform bool discardBackgroundColor;\n  uniform vec3 backgroundColor;\n  uniform float backgroundColorTolerance;\n\n  varying vec4 vColor;\n  varying float vLifetime;\n  varying float vStartLifetime;\n  varying float vRotation;\n  varying float vStartFrame;\n\n  void main()\n  {\n    gl_FragColor = vColor;\n    float mid = 0.5;\n\n    float frameIndex = round(vStartFrame) + (\n      useFPSForFrameIndex == true\n        ? fps == 0.0\n            ? 0.0\n            : max((vLifetime / 1000.0) * fps, 0.0)\n        : max(min(floor(min(vLifetime / vStartLifetime, 1.0) * (tiles.x * tiles.y)), tiles.x * tiles.y - 1.0), 0.0)\n    );\n        \n    float spriteXIndex = floor(mod(frameIndex, tiles.x));\n    float spriteYIndex = floor(mod(frameIndex / tiles.x, tiles.y));\n\n    vec2 frameUV = vec2(\n      gl_PointCoord.x / tiles.x + spriteXIndex / tiles.x,\n      gl_PointCoord.y / tiles.y + spriteYIndex / tiles.y);\n\n    vec2 center = vec2(0.5, 0.5);\n    vec2 centeredPoint = gl_PointCoord - center;\n\n    mat2 rotation = mat2(\n      cos(vRotation), sin(vRotation),\n      -sin(vRotation), cos(vRotation)\n    );\n\n    centeredPoint = rotation * centeredPoint;\n    vec2 centeredMiddlePoint = vec2(\n      centeredPoint.x + center.x,\n      centeredPoint.y + center.y\n    );\n\n    float dist = distance(centeredMiddlePoint, center);\n    if (dist > 0.5) discard;\n\n    vec2 uvPoint = vec2(\n      centeredMiddlePoint.x / tiles.x + spriteXIndex / tiles.x,\n      centeredMiddlePoint.y / tiles.y + spriteYIndex / tiles.y\n    );\n\n    vec4 rotatedTexture = texture2D(map, uvPoint);\n\n    gl_FragColor = gl_FragColor * rotatedTexture;\n\n    if (discardBackgroundColor && abs(length(rotatedTexture.rgb - backgroundColor.rgb)) < backgroundColorTolerance ) discard;\n  }\n",transparent:_.transparent,blending:_.blending,depthTest:_.depthTest,depthWrite:_.depthWrite}),G=new y.BufferGeometry;for(let t=0;t<z;t++)k(i,S,m,Q[t],W[t]);G.setFromPoints(Array.from({length:z},((t,e)=>Q[e].clone())));const H=(t,e)=>{(({geometry:t,propertyName:e,maxParticles:r,factory:i})=>{t.setAttribute(e,new y.BufferAttribute(new Float32Array(Array.from({length:r},"function"==typeof i?i:()=>i)),1))})({geometry:G,propertyName:t,maxParticles:z,factory:e})};H("isActive",0),H("lifetime",0),H("startLifetime",(()=>1e3*O(i.particleSystemId,u,0))),H("startFrame",(()=>U.startFrame?O(i.particleSystemId,U.startFrame,0):0)),H("opacity",(()=>O(i.particleSystemId,h,0))),H("rotation",(()=>O(i.particleSystemId,f,0))),H("size",((t,e)=>i.startValues.startSize[e])),H("rotation",0);const q=Math.random();H("colorR",(()=>v.min.r+q*(v.max.r-v.min.r))),H("colorG",(()=>v.min.g+q*(v.max.g-v.min.g))),H("colorB",(()=>v.min.b+q*(v.max.b-v.min.b))),H("colorA",0);let $=new y.Points(G,j);$.position.copy(o.position),$.rotation.x=y.MathUtils.degToRad(o.rotation.x),$.rotation.y=y.MathUtils.degToRad(o.rotation.y),$.rotation.z=y.MathUtils.degToRad(o.rotation.z),$.scale.copy(o.scale);const Y=r+1e3*O(i.particleSystemId,d);let X;"WORLD"===a.simulationSpace&&(X=new T,X.add($)),N.push({particleSystem:$,wrapper:X,generalData:i,onUpdate:V,onComplete:E,creationTime:Y,lastEmissionTime:Y,duration:s,looping:c,simulationSpace:M,gravity:g,emission:A,normalizedConfig:a,iterationCount:0,velocities:W,deactivateParticle:t=>{G.attributes.isActive.array[t]=0,G.attributes.colorA.array[t]=0,G.attributes.colorA.needsUpdate=!0},activateParticle:({particleIndex:t,activationTime:e,position:r})=>{G.attributes.isActive.array[t]=1,i.creationTimes[t]=e,i.noise.offsets&&(i.noise.offsets[t]=100*Math.random());const n=Math.random();G.attributes.colorR.array[t]=v.min.r+n*(v.max.r-v.min.r),G.attributes.colorR.needsUpdate=!0,G.attributes.colorG.array[t]=v.min.g+n*(v.max.g-v.min.g),G.attributes.colorG.needsUpdate=!0,G.attributes.colorB.array[t]=v.min.b+n*(v.max.b-v.min.b),G.attributes.colorB.needsUpdate=!0,G.attributes.startFrame.array[t]=U.startFrame?O(i.particleSystemId,U.startFrame,0):0,G.attributes.startFrame.needsUpdate=!0,G.attributes.startLifetime.array[t]=1e3*O(i.particleSystemId,u,i.normalizedLifetimePercentage),G.attributes.startLifetime.needsUpdate=!0,i.startValues.startSize[t]=O(i.particleSystemId,p,i.normalizedLifetimePercentage),G.attributes.size.array[t]=i.startValues.startSize[t],G.attributes.size.needsUpdate=!0,i.startValues.startOpacity[t]=O(i.particleSystemId,h,i.normalizedLifetimePercentage),G.attributes.colorA.array[t]=i.startValues.startOpacity[t],G.attributes.colorA.needsUpdate=!0,G.attributes.rotation.array[t]=O(i.particleSystemId,f,i.normalizedLifetimePercentage),G.attributes.rotation.needsUpdate=!0,a.rotationOverLifetime.isActive&&(i.lifetimeValues.rotationOverLifetime[t]=y.MathUtils.randFloat(a.rotationOverLifetime.min,a.rotationOverLifetime.max)),k(i,S,m,Q[t],W[t]);const o=Math.floor(3*t);G.attributes.position.array[o]=r.x+Q[t].x,G.attributes.position.array[o+1]=r.y+Q[t].y,G.attributes.position.array[o+2]=r.z+Q[t].z,G.attributes.position.needsUpdate=!0,i.linearVelocityData&&i.linearVelocityData[t].speed.set(a.velocityOverLifetime.linear.x?O(i.particleSystemId,a.velocityOverLifetime.linear.x,0):0,a.velocityOverLifetime.linear.y?O(i.particleSystemId,a.velocityOverLifetime.linear.y,0):0,a.velocityOverLifetime.linear.z?O(i.particleSystemId,a.velocityOverLifetime.linear.z,0):0),i.orbitalVelocityData&&(i.orbitalVelocityData[t].speed.set(a.velocityOverLifetime.orbital.x?O(i.particleSystemId,a.velocityOverLifetime.orbital.x,0):0,a.velocityOverLifetime.orbital.y?O(i.particleSystemId,a.velocityOverLifetime.orbital.y,0):0,a.velocityOverLifetime.orbital.z?O(i.particleSystemId,a.velocityOverLifetime.orbital.z,0):0),i.orbitalVelocityData[t].positionOffset.set(Q[t].x,Q[t].y,Q[t].z)),G.attributes.lifetime.array[t]=0,G.attributes.lifetime.needsUpdate=!0,P({delta:0,generalData:i,normalizedConfig:a,attributes:$.geometry.attributes,particleLifetimePercentage:0,particleIndex:t})}});return{instance:X||$,resumeEmitter:()=>i.isEnabled=!0,pauseEmitter:()=>i.isEnabled=!1,dispose:()=>(t=>{N=N.filter((({particleSystem:e,wrapper:r,generalData:{particleSystemId:i}})=>e!==t&&r!==t||(l(i),e.geometry.dispose(),Array.isArray(e.material)?e.material.forEach((t=>t.dispose())):e.material.dispose(),e.parent&&e.parent.remove(e),!1)))})($)}},j=({now:t,delta:e,elapsed:r})=>{N.forEach((i=>{const{onUpdate:a,generalData:n,onComplete:o,particleSystem:s,wrapper:l,creationTime:c,lastEmissionTime:d,duration:u,looping:m,emission:p,normalizedConfig:f,iterationCount:v,velocities:h,deactivateParticle:g,activateParticle:x,simulationSpace:b,gravity:I}=i,M=t-c,z=M%(1e3*u);n.normalizedLifetimePercentage=Math.max(Math.min(z/(1e3*u),1),0);const{lastWorldPosition:w,currentWorldPosition:A,worldPositionChange:S,lastWorldQuaternion:_,worldQuaternion:C,worldEuler:L,gravityVelocity:V,isEnabled:T}=n;l?.parent&&n.wrapperQuaternion.copy(l.parent.quaternion);const E={...w};if(Array.isArray(s.material)?s.material.forEach((t=>{t instanceof y.ShaderMaterial&&(t.uniforms.elapsed.value=r)})):s.material instanceof y.ShaderMaterial&&(s.material.uniforms.elapsed.value=r),s.getWorldPosition(A),-99999!==w.x&&S.set(A.x-w.x,A.y-w.y,A.z-w.z),n.distanceFromLastEmitByDistance+=S.length(),s.getWorldPosition(w),s.getWorldQuaternion(C),-99999!==_.x&&_.x===C.x&&_.y===C.y&&_.z===C.z||(L.setFromQuaternion(C),_.copy(C),V.set(w.x,w.y+I,w.z),s.worldToLocal(V)),n.creationTimes.forEach(((r,i)=>{if(s.geometry.attributes.isActive.array[i]){const a=t-r;if(a>s.geometry.attributes.startLifetime.array[i])g(i);else{const t=h[i];if(t.x-=V.x*e,t.y-=V.y*e,t.z-=V.z*e,0!==I||0!==t.x||0!==t.y||0!==t.z||0!==S.x||0!==S.y||0!==S.z){const r=3*i,a=s.geometry.attributes.position.array;"WORLD"===b&&(a[r]-=S.x,a[r+1]-=S.y,a[r+2]-=S.z),a[r]+=t.x*e,a[r+1]+=t.y*e,a[r+2]+=t.z*e,s.geometry.attributes.position.needsUpdate=!0}s.geometry.attributes.lifetime.array[i]=a,s.geometry.attributes.lifetime.needsUpdate=!0;const r=a/s.geometry.attributes.startLifetime.array[i];P({delta:e,generalData:n,normalizedConfig:f,attributes:s.geometry.attributes,particleLifetimePercentage:r,particleIndex:i})}}})),T&&(m||M<1e3*u)){const o=t-d,l=p.rateOverTime?Math.floor(O(n.particleSystemId,p.rateOverTime,n.normalizedLifetimePercentage)*(o/1e3)):0,c=p.rateOverDistance?O(n.particleSystemId,p.rateOverDistance,n.normalizedLifetimePercentage):0,u=c>0&&n.distanceFromLastEmitByDistance>0?Math.floor(n.distanceFromLastEmitByDistance/(1/c)):0,m=u>0?{x:(A.x-E.x)/u,y:(A.y-E.y)/u,z:(A.z-E.z)/u}:null,y=l+u;if(c>0&&u>=1&&(n.distanceFromLastEmitByDistance=0),y>0){let e=0;for(let r=0;r<y;r++){let r=-1;if(s.geometry.attributes.isActive.array.find(((t,e)=>!t&&(r=e,!0))),-1!==r&&r<s.geometry.attributes.isActive.array.length){let a={x:0,y:0,z:0};m&&e<u&&(a={x:m.x*e,y:m.y*e,z:m.z*e},e++),x({particleIndex:r,activationTime:t,position:a}),i.lastEmissionTime=t}}}a&&a({particleSystem:s,delta:e,elapsed:r,lifetime:M,normalizedLifetime:z,iterationCount:v+1})}else o&&o({particleSystem:s})}))};var G=a.pB,H=a.U_,q=a.rU,$=a.M4,Y=a.$H,X=a.hp,J=a.l$,K=a.Y$,Z=a.Tt,tt=a.JP,et=a.eL,rt=a.Hc,it=a.Ao,at=a.iy,nt=a.Px,ot=a.rJ,st=a.Pj,lt=a.YR;export{G as applyModifiers,H as blendingMap,q as calculateRandomPositionAndVelocityOnBox,$ as calculateRandomPositionAndVelocityOnCircle,Y as calculateRandomPositionAndVelocityOnCone,X as calculateRandomPositionAndVelocityOnRectangle,J as calculateRandomPositionAndVelocityOnSphere,K as calculateValue,Z as createBezierCurveFunction,tt as createDefaultParticleTexture,et as createParticleSystem,rt as getBezierCacheSize,it as getCurveFunction,at as getCurveFunctionFromConfig,nt as getDefaultParticleSystemConfig,ot as isLifeTimeCurve,st as removeBezierCurveFunction,lt as updateParticleSystems};